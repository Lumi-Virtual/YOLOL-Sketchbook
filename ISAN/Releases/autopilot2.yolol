// get last, ship, destination vectors
// rotate ship and dest such that ship would be towards 0,y,0
// save difference in angle from ship to last and dest. to correct movement multilpiers
// rotate dest around ship by the angle between ship and dest, ignoring y
// get dest p and h and autopilot with those times the direction sensitivities

//--+----|----+----|----+----|----+----|----+----|----+----|----+----|
goto1+:Autopilot
:FcuForward=100 :FcuRotationalPitch=0 :FcuRotationalYaw=0

a // p+
b // p-
c // y+
d // y-
e // temp
f // temp
gh // last PY
ijk // last
l // 
m // 
n // step counter
opq // dest alt
rst // ship alt
uvw // dest
xyz // ship

// get last, ship, destination vectors
i=x j=y k=z                                                         //Last ship dir [r-space]
x=:I-:X  y=:J-:Y  z=:K-:Z  m=sqrt(x^2+y^2+z^2) x/=m y/=m z/=m       //Ship dir      [r-space]
u=:X-:DX v=:DY-:Y w=:DZ-:Z n=sqrt(u^2+v^2+w^2) u/=n v/=n w/=n       //dest dir      [r-space]


//last => 0,1,0 
// & current ship dir on xy plane   (aka last X current -> 0,1,0)


// Y = last
// Z = last ** current
// X = last ** (last ** current)  || flatten current onto plane specd by last

// double double cross (double det)
// double 90 (2d*), 2d rotation

// X  Y  Z
// i  i  j         x       i*x + i*y + j*z
// k  j -i    X    y   =   k*x + j*y - i*z
//-j  k  k         z

r=i*x+j*y+j*z     //rotate x,y,z (ship dir) into the "last on y" space (ly-space)
s=k*x+j*y-i*z     
t=-j*x+k*y+k*z

o=i*u+j*v+j*w      //rotate u,v,w (dest dir) into the "last on y" space (ly-space)
p=k*u+j*v-i*w      
q=-j*u+k*v+k*w



// correct multipliers
e=sqrt(x^2+z^2) f=sqrt(u^2+w^2) f=atan(f/v)+180+(v>0)*((f<0)-0.5)*360
f/=atan(e/y)+180+(y>0)*((e<0)-0.5)*360
:a*=f*(g>0) :b*=f*(g<0) :c*=f*(h>0) :d*=f*(h<0)



//(angle of dest  dir from xy plane)-(angle of ship dir from xy plane)
e=atan(o/q)-atan(r/t)+((o>0)*(q<0-0.5)-(r>0)*(t<0-0.5))*360


// create "fake" dest vector by rotating dest around ship by correction
i=cos e j=sin e k=1-cos e
o=(i+x^2*k)*u+(x*y*k-z*j)*v+(x*z*k+y*j)*w
p=(x*y*k+z*j)*u+(i+y^2*k)*v+(y*z*k-x*j)*w
q=(z*x*k-y*j)*u+(z*y*k+x*j)*v+(i+z^2*k)*w




// get dest p and h and autopilot with those times the direction sensitivities
e=sqrt(x^2+y^2) :P=atan(z/e) :H=atan(x/y)+180+(y>0)*((x<0)-0.5)*360

x=x-u y=v-y z=w-z e=sqrt(x^2+y^2) :DD=sqrt(x^2+y^2+z^2)
:DP=atan(z/e) :DH=atan(x/y)+180+(y>0)*((x<0)-0.5)*360

// degrees
g=:P-:DP h=(((:H-:DH+180)%360)-180)

// total steps
g*=a*(g>0)+b*(g<0) h*=c*(h>0)+d*(h<0)

// duration
n=((g+(h-g)*(h>g))/100+0.999)/1000*1000 // maybe set the 0.999 to 0.5 so it cuts off if its real close to the target

// step size
g/=n h/=n

// loop
:FcuRotationalPitch=g :FcuRotationalYaw=h n-- goto#+n<1


//--+----|----+----|----+----|----+----|----+----|----+----|----+----|
//--+----| funky version just to see how everything fits, not complete
goto1+:Autopilot
:FcuForward=100 :FcuRotationalPitch=0 :FcuRotationalYaw=0
goto3+sqrt((:I-:X)^2+(:J-:Y)^2+(:K-:Z)^2)
i=x j=y k=z x=:I-:X y=:J-:Y z=:K-:Z m=sqrt(x^2+y^2+z^2) x/=m y/=m z/=m
u=:X-:DX v=:DY-:Y w=:DZ-:Z n=sqrt(u^2+v^2+w^2) u/=n v/=n w/=n r=i*x
r+=j*y+j*z s=k*x+j*y-i*z t=k*y+k*z-j*x o=i*u+j*v+j*w p=k*u+j*v-i*w
q=k*v+k*w-j*u e=sqrt(x^2+z^2) f=sqrt(u^2+w^2) f=(v>0)*((f<0)-0.5)*360
f+=atan(f/v)+180 f/=atan(e/y)+180+(y>0)*((e<0)-0.5)*360 :APP*=f*(g>0)
:APN*=f*(g<0) :AYP*=f*(h>0) :AYN*=f*(h<0) e=atan(o/q)-atan(r/t)
e+=((o>0)*(q<0-0.5)-(r>0)*(t<0-0.5))*360 i=cos e j=sin e k=1-cos e
o=(i+x^2*k)*u+(x*y*k-z*j)*v+(x*z*k+y*j)*w p=(x*y*k+z*j)*u+(i+y^2*k)*v
p+=(y*z*k-x*j)*w q=(z*x*k-y*j)*u+(z*y*k+x*j)*v+(i+z^2*k)*w
e=sqrt(x^2+y^2) :P=atan(z/e) :H=atan(x/y)+180+(y>0)*((x<0)-0.5)*360
x=x-u y=v-y z=w-z e=sqrt(x^2+y^2) :DD=sqrt(x^2+y^2+z^2) :DP=atan(z/e)
:DH=atan(x/y)+180+(y>0)*((x<0)-0.5)*360 g=:P-:DP h=(:H-:DH+180)%360-180
g*=:APP*(g>0)+:APN*(g<0) h*=:AYP*(h>0)+:AYN*(h<0) n=g+(h-g)*(h>g)
n=(n/100+0.999)/1000*1000 g/=n h/=n
:FcuRotationalPitch=g :FcuRotationalYaw=h n-- goto18-(n<1)*20
//--+----|----+----|----+----|----+----|----+----|----+----|----+----|


//--+----|----+----|----+----|----+----|----+----|----+----|----+----|
goto1+:Autopilot
:FcuForward=100 :FcuRotationalPitch=0 :FcuRotationalYaw=0
//--+----| Wait til full speed
goto3+sqrt((:I-:X)^2+(:J-:Y)^2+(:K-:Z)^2) //+ check if we go about the same speed next tick
//--+----| Get last, ship, and dest vectors. Then normalize them
i=x j=y k=z
x=:I-:X y=:J-:Y z=:K-:Z m=sqrt(x^2+y^2+z^2) x/=m y/=m z/=m
u=:X-:DX v=:DY-:Y w=:DZ-:Z n=sqrt(u^2+v^2+w^2) u/=n v/=n w/=n
//--+----| Put ship and dest on a new unit plane tangent to last
r=i*x+j*y+j*z s=k*x+j*y-i*z t=k*y+k*z-j*x
o=i*u+j*v+j*w p=k*u+j*v-i*w q=k*v+k*w-j*u
//--+----| Get the angle difference from last to ship and to dest
e=sqrt(x^2+z^2) f=sqrt(u^2+w^2) f=atan(f/v)+180+(v>0)*((f<0)-0.5)*360
f/=atan(e/y)+180+(y>0)*((e<0)-0.5)*360
//--+----| Correct multipliers
:APP*=f*(g>0) :APN*=f*(g<0) :AYP*=f*(h>0) :AYN*=f*(h<0)
//--+----| Get the angle difference on the plane between ship and dest
e=atan(o/q)-atan(r/t)+((o>0)*(q<0-0.5)-(r>0)*(t<0-0.5))*360
//--+----| Rotate dest around ship the ammount we were off last move
i=cos e j=sin e k=1-cos e
o=(i+x^2*k)*u+(x*y*k-z*j)*v+(x*z*k+y*j)*w
p=(x*y*k+z*j)*u+(i+y^2*k)*v+(y*z*k-x*j)*w
q=(z*x*k-y*j)*u+(z*y*k+x*j)*v+(i+z^2*k)*w
//--+----| Get ship and dest pitch and headings
e=sqrt(x^2+y^2) :P=atan(z/e) :H=atan(x/y)+180+(y>0)*((x<0)-0.5)*360
x=x-u y=v-y z=w-z e=sqrt(x^2+y^2) :DD=sqrt(x^2+y^2+z^2)
:DP=atan(z/e) :DH=atan(x/y)+180+(y>0)*((x<0)-0.5)*360
//--+----| Convert to degrees
g=:P-:DP h=(:H-:DH+180)%360-180
//--+----| Then to total steps
g*=:APP*(g>0)+:APN*(g<0) h*=:AYP*(h>0)+:AYN*(h<0)
//--+----| Then to duration
n=((g+(h-g)*(h>g))/100+0.999)/1000*1000 // maybe set the 0.999 to 0.5 so it cuts off if its real close to the target
//--+----| And step size
g/=n h/=n
//--+----| Piloting loop
:FcuRotationalPitch=g :FcuRotationalYaw=h n-- goto#+n<1
//--+----| Wait til we stop rotating
goto ()*#
//--+----|----+----|----+----|----+----|----+----|----+----|----+----|


// cleanup the variables
a // p+
b // p-
c // y+
d // y-
e // temp
f // temp
gh // last PY
ijk //* last
l // 
m // 
n // step counter
opq //* dest alt
rst //* ship alt
uvw //* dest
xyz //* ship
//--+----|----+----|----+----|----+----|----+----|----+----|----+----|
goto1+:Autopilot
:FcuForward=100 :FcuRotationalPitch=0 :FcuRotationalYaw=0
//--+----| Wait til full speed
goto3+sqrt((:I-:X)^2+(:J-:Y)^2+(:K-:Z)^2) //+ check if we go about the same speed next tick
//--+----| Get last, ship, and dest vectors. Then normalize them
i=x j=y k=z
x=:I-:X y=:J-:Y z=:K-:Z m=sqrt(x^2+y^2+z^2) x/=m y/=m z/=m
u=:X-:DX v=:DY-:Y w=:DZ-:Z n=sqrt(u^2+v^2+w^2) u/=n v/=n w/=n
//--+----| Antialign ship and dest to a plane tangent to last
r=i*x+j*y+j*z s=k*x+j*y-i*z t=k*y+k*z-j*x
o=i*u+j*v+j*w p=k*u+j*v-i*w q=k*v+k*w-j*u
//--+----| Get the on plane angle between ship and dest
e=atan(o/q)-atan(r/t)+((o>0)*(q<0-0.5)-(r>0)*(t<0-0.5))*360
//--+----| Get the angle difference between last to ship and last to dest
e=sqrt(r^2+t^2) f=sqrt(o^2+q^2) f=atan(f/p)+180+(p>0)*((f<0)-0.5)*360
f/=atan(e/s)+180+(s>0)*((e<0)-0.5)*360
//--+----| Correct multipliers
:APP*=f*(g>0) :APN*=f*(g<0) :AYP*=f*(h>0) :AYN*=f*(h<0)
//--+----| Rotate dest around ship by the ammount we were off by last move
i=cos e j=sin e k=1-cos e
o=(i+x^2*k)*u+(x*y*k-z*j)*v+(x*z*k+y*j)*w
p=(x*y*k+z*j)*u+(i+y^2*k)*v+(y*z*k-x*j)*w
q=(z*x*k-y*j)*u+(z*y*k+x*j)*v+(i+z^2*k)*w
//--+----| Get ship and dest pitch and headings
e=sqrt(x^2+y^2) :P=atan(z/e) :H=atan(x/y)+180+(y>0)*((x<0)-0.5)*360
x=x-o y=p-y z=q-z e=sqrt(x^2+y^2) :DD=sqrt(x^2+y^2+z^2)
:DP=atan(z/e) :DH=atan(x/y)+180+(y>0)*((x<0)-0.5)*360
//--+----| Convert to degrees
g=:P-:DP h=(:H-:DH+180)%360-180
//--+----| Then to total steps
g*=:APP*(g>0)+:APN*(g<0) h*=:AYP*(h>0)+:AYN*(h<0)
//--+----| Then to duration
n=((g+(h-g)*(h>g))/100+0.999)/1000*1000 //~ approaches instead of actually gets to dest
//--+----| And step size
g/=n h/=n
//--+----| Piloting loop
:FcuRotationalPitch=g :FcuRotationalYaw=h n-- goto#+n<1
//--+----| Wait til we stop rotating
goto ()*#
//--+----|----+----|----+----|----+----|----+----|----+----|----+----|
